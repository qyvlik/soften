# 自定义汇编

汇编由一条条指令构成。指令执行之后有执行状态和返回值。

> 图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作：
> 在纸上写上或擦除某个符号；
> 把注意力从纸的一个位置移动到另一个位置；

## 空格

指令与操作数，操作数与操作数之间只能有一个空格，结尾以回车结束。

## 定义对象或变量

```
DECLRAR @object_name value
```

```
// var object;
DECLRAR @object $NULL

// int a = 10;
DECLRAR @a 10

// int b = a;
DECLRAR @a @b
```

一条指令只能声明一个变量或者对象。

## 构造对象

```
NEW object_type
```

```
// new Object;
NEW Object
```

```
// var object = new Object;
NEW Object
DECLARA @object $CACHE
```

`$CACHE` 是上条指令运行之后的返回值。

## 对象间赋值

```
ASSIGN @targer @source
```

```
// int a  = 10;
// int b;
// b = a;

DECLARA @a 10
DECLARA @b 0
ASSIGN @b @a
```

## 将某个对象加特定对象上

```
// targer += source
ASSIGN_ADD @targer @source
```

```
int a, b;
a  = 0 ;
a += b;

DECLARA @a 0
DECLARA @b 0
ASSIGN @a 0
ASSIGN_ADD @a @b
```

其他类似操作：

> T(ASSIGN_ADD, "+=", 2)  
> T(ASSIGN_SUB, "-=", 2)  
> T(ASSIGN_MUL, "*=", 2)  
> T(ASSIGN_DIV, "/=", 2)  
> T(ASSIGN_MOD, "%=", 2)  

## 对象间运算操作

```
lhs + rhs;
ADD @lhs @rhs
```

```
int a, b, c;
a = 0;
b = 1;
c = a + b;

DECLARA @a 0
DECLARA @b 0
DECLARA @c 0
ASSIGN @a 0
ASSIGN @b 1
ADD @a @b
ASSIGN @c $CACHE
```

> T(ADD, "+", 12)  
> T(SUB, "-", 12)  
> T(MUL, "*", 13)  
> T(DIV, "/", 13)  
> T(MOD, "%", 13)  

## 原生函数调用

```

result = function_name(arg0, arg1);

PUSH $ARGRMENTS @arg0
PUSH $ARGRMENTS @arg1
CALL @function_name $ARGRMENTS
ASSIGN $ARGRMENTS $EMPTY
ASSIGN @result $CACHE
```

```
ASSIGN $ARGRMENTS $EMPTY
```

这一句是清空参数表的意思。

## 流程跳转

~~还没有思路~~

```
GOTO ? label1:label2
```

`GOTO` 指令不会刷新 `$CACHE`，但仍然有执行后的状态值。

```
a = b;
if(a == b) {
    // 1
    a = 1;
} else {
    // 2
    a = 2;
}
    // 3

ASSIGN @a @b
EQ @a @b
GOTO $CACHE 1:2
LABEL 1 :
ASSIGN @a 1
GOTO TRUE 3:3
LABEL 2 :
ASSIGN @a 2
GOTO TRUE 3:3
LABEL 3 :

```

## 不支持函数定义，不支持递归

## 运行

### 指令生成

```

struct State {
    int state_code;
    int line;
};

State run(FILE *file) {
    char operation[40];
    char first[40];
    char second[400];
    while(fscanf(fp, "%s %s %s\n", operation, first, second) ) {
        push(instruction);
    }
}

```

### 指令执行

指令执行之后又执行状态和返回值。

例如执行指令过程中发现类型不匹配，返回值大于零。

```
std::map<const std::string, bridge*> object_table;

typedef std::map<const std::string, bridge*> variant;

enum Return {};

Return run_instruction(std::string& operation, variant& target, list<variant&> args, variant& result);
```
